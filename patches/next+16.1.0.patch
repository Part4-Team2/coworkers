diff --git a/node_modules/next/dist/client/components/use-action-queue.js b/node_modules/next/dist/client/components/use-action-queue.js
index 0584a41..f9f2eba 100644
--- a/node_modules/next/dist/client/components/use-action-queue.js
+++ b/node_modules/next/dist/client/components/use-action-queue.js
@@ -39,8 +39,26 @@ function dispatchAppRouterAction(action) {
 }
 const __DEV__ = process.env.NODE_ENV !== 'production';
 const promisesWithDebugInfo = __DEV__ ? new WeakMap() : null;
+
+// ðŸ”§ Patch: use() í›… ë²„ê·¸ ìš°íšŒë¥¼ ìœ„í•œ useUnwrapState
+function useUnwrapState(_state) {
+    const [state, setState] = _react.default.useState(_state);
+    _react.default.useEffect(() => {
+        if ((0, _isthenable.isThenable)(_state)) {
+            _state.then(setState);
+        } else {
+            setState(_state);
+        }
+    }, [_state]);
+    return state;
+}
+
 function useActionQueue(actionQueue) {
     const [state, setState] = _react.default.useState(actionQueue.state);
+    
+    // ðŸ”§ Patch: use() ëŒ€ì‹  useUnwrapState ì‚¬ìš©
+    const unwrappedState = useUnwrapState(state);
+    
     // Because of a known issue that requires to decode Flight streams inside the
     // render phase, we have to be a bit clever and assign the dispatch method to
     // a module-level variable upon initialization. The useState hook in this
@@ -90,7 +108,8 @@ function useActionQueue(actionQueue) {
     }, [
         state
     ]);
-    return (0, _isthenable.isThenable)(stateWithDebugInfo) ? (0, _react.use)(stateWithDebugInfo) : stateWithDebugInfo;
+    // ðŸ”§ Patch: use() í˜¸ì¶œ ì œê±° - useUnwrapStateë¡œ ëŒ€ì²´
+    return unwrappedState;
 }
 
 if ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {
